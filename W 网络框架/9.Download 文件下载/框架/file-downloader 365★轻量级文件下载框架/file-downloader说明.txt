https://github.com/wlfcolin/file-downloader

一、特点
多任务并行下载、自动断点续传、失败自动重试机制、支持大文件（超过2G）下载、强大方便的异常处理和异常恢复机制、轻松管理下载文件的生命周期（下载文件的增删改查）等。

二、非常适合的使用场景
1、需要多页面多方位同步下载进度和下载状态（比如商店APP，A页面开启点击下载，B页面和C页面也可以看到下载进度和暂停这个下载，而D页面 可以删除这个下载，无论哪个页面有操作，其它页面都会收到响应的回调进行更新，并且还可能还需要常驻一个service来把下载情况同步发送到通知栏的）

2、需要断点续传节约流量（比如做批量应用更新APP、单个应用自己更新下载新版本、做影视需要批量缓存视频的APP，做MP3歌曲下载APP）

3、专门做下载的（比如迅雷之类的APP，需要下载任何服务器上的东西，并且兼顾下载效率和开发效率的）


四、快速上手使用
第一步、在项目模块的build.gradle配置gradle

compile 'org.wlf:FileDownloader:0.3.2'


    添加权限
    <!-- network permissions -->
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/>
    <uses-permission android:name="android.permission.INTERNET"/>
    <!-- write file permissions -->
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>


第二步、在你的应用application的onCreate()中初始化FileDownloader
    //初始化文件下载
    private void initFileDownload() {
        // 1、创建Builder
        FileDownloadConfiguration.Builder builder = new FileDownloadConfiguration.Builder(this);

        // 2.配置Builder
        // 配置下载文件保存的文件夹
        builder.configFileDownloadDir(Environment.getExternalStorageDirectory().getAbsolutePath()
                + File.separator + "EDUDownload");///storage/emulated/0/EDUDownload
        // 配置同时下载任务数量，如果不配置默认为2
        builder.configDownloadTaskSize(5);
        // 配置失败时尝试重试的次数，如果不配置默认为0不尝试
        builder.configRetryDownloadTimes(1);
        // 开启调试模式，方便查看日志等调试相关，如果不配置默认不开启
        builder.configDebugMode(false);
        // 配置连接网络超时时间，如果不配置默认为15秒
        builder.configConnectTimeout(10000);// 25秒

        // 3、使用配置文件初始化FileDownloader
        FileDownloadConfiguration configuration = builder.build();
        FileDownloader.init(configuration);
    }


API
DownloadFileInfo downloadFile = FileDownloader.getDownloadFile("url");//获取下载信息(如果为null,说明没有下载)
List<DownloadFileInfo> downloadFiles = FileDownloader.getDownloadFiles();//获取下载列表
downloadFileInfo.getDownloadedSizeLong();//获取已经下载的大小
downloadFileInfo.getFileSizeLong();获取下载文件的大小
downloadFileInfo.getUrl();获取url


//#########################################################################################
            //初始化下载状态(如果你刚进页面就需要获取状态的话,本例来自EDU),写在activity/fragment层
            rankListPresenter.initDownloadStatus(appData.get(position).appId, appData.get
                    (position).packageName, appData.get(position).appUrl, ApkUtil
                    .checkAppInstalled(getActivity(), appData.get(position).packageName),
                    viewHolder.tvProgress, viewHolder.pbProgress);//初始化下载状态
    

    //初始化下载状态(adapter中调用),写在Presenter层中
    //isApkInstalled手机中是否安装了这个应用,写在activity/fragment层
    public void initDownloadStatus(String appId, String packageName, String appUrl, boolean
            isApkInstalled, TextView textView, ProgressBar pbProgress) {
        textView.setText("下载");
        pbProgress.setProgress(0);//初始化,不然有莫名其妙的复用,重要!!!!!
        if (isApkInstalled) {
            textView.setText("打开");
        }
        //更新应用列表
        ArrayList<UpdateAppGson.DataBean> updateAppInfo = (ArrayList<UpdateAppGson.DataBean>)
                aCache.getAsObject(Global.UPDATEAPPINFO);
        for (int i = 0; i < updateAppInfo.size(); i++) {
            if (updateAppInfo.get(i).appId.equals(appId)) {//这个app在更新列表
                Integer versionNo = iRankListView.getVersionNo(packageName);
                //并且这个app不是最新版本
                if (versionNo != null && versionNo < updateAppInfo.get(i).versionNo) {
                    textView.setText("更新");
                }
                break;
            }
        }

        DownloadFileInfo downloadFile = FileDownloader.getDownloadFile(appUrl);
        if (downloadFile != null) {
            switch (downloadFile.getStatus()) {
                case Status.DOWNLOAD_STATUS_DOWNLOADING:
                    textView.setText(downloadFile.getDownloadedSizeLong() * 100 /
                            downloadFile.getFileSizeLong() + "%");
                    pbProgress.setProgress((int) (downloadFile.getDownloadedSizeLong() * 100 /
                            downloadFile.getFileSizeLong()));
                    break;
                case Status.DOWNLOAD_STATUS_COMPLETED:
                    pbProgress.setProgress(100);
                    if (isApkInstalled) {//如果已安装
                        textView.setText("打开");
                        for (int i = 0; i < updateAppInfo.size(); i++) {
                            if (updateAppInfo.get(i).appId.equals(appId)) {
                                Integer versionNo = iRankListView.getVersionNo(packageName);
                                //如果是最新版本
                                if (versionNo != null && versionNo < updateAppInfo.get(i)
                                        .versionNo) {
                                    textView.setText("安装");
                                    break;
                                }
                            }
                        }
                    } else {//没有安装
                        textView.setText("安装");
                    }
                    break;
                case Status.DOWNLOAD_STATUS_ERROR:
                    textView.setText("重试");
                    break;
                case Status.DOWNLOAD_STATUS_PAUSED:
                    pbProgress.setProgress((int) (downloadFile.getDownloadedSizeLong() * 100 /
                            downloadFile.getFileSizeLong()));
                    textView.setText("暂停");
                    break;
                case Status.DOWNLOAD_STATUS_WAITING:
                    textView.setText("排队中...");
                    break;
                case DOWNLOAD_STATUS_RETRYING:
                    textView.setText("重试");
                    break;
                default:
                    break;
            }
        }
    }

//#########################################################################################
    //点击更新下载状态(adapter的点击事件中调用),写在Presenter层中
    public void clickToUpdateDownloadStatus(String appUrl, String packageName, TextView textView) {
        //本机已安装
        if (!TextUtils.isEmpty(textView.getText()) && textView.getText().toString().contains
                ("打开")) {
            iRankListView.openApk(packageName);
            return;
        }
        DownloadFileInfo downloadFile = FileDownloader.getDownloadFile(appUrl);
        if (downloadFile != null) {
            switch (downloadFile.getStatus()) {
                case Status.DOWNLOAD_STATUS_FILE_NOT_EXIST://文件不存在,这儿一定要判断,当删除文件后再下载的时候会进这里面
                    FileDownloader.reStart(appUrl);
                    break;
                case Status.DOWNLOAD_STATUS_DOWNLOADING://下载中
                    FileDownloader.pause(appUrl);//暂停
                    textView.setText("暂停");
                    break;
                case Status.DOWNLOAD_STATUS_COMPLETED:
                    if (!TextUtils.isEmpty(textView.getText())) {
                        if (textView.getText().toString().contains("打开")) {
                            iRankListView.openApk(packageName);
                        }
                        if (textView.getText().toString().contains("安装")) {
                            iRankListView.installApk(downloadFile);//安装
                        }
                    }
                    break;
                default:
                    FileDownloader.start(appUrl);//开始
                    break;
            }
        } else {
            FileDownloader.start(appUrl);//开始
        }
    }


    //打开应用,写在activity/fragment层
    @Override
    public void openApk(String packageName) {
        if (!TextUtils.isEmpty(packageName)) {
            if (packageName.equals(getActivity().getPackageName())) {
                toast("自己不能打开自己");
            } else {
                ApkUtil.openAPK(getActivity(), packageName);
            }
        }
    }


    //安装应用,下载完成和手动点击都会调用这个,写在activity/fragment层
    //DownloadFileInfo downloadFileInfo;
    @Override
    public void installApk(DownloadFileInfo downloadFileInfo) {
        //this.downloadFileInfo = downloadFileInfo;
        ApkUtil.installApk(getActivity(), downloadFileInfo.getFilePath());
    }


    //用于安装完成后更新显示,例:把"安装"显示成"打开"
    @Override
    public void onResume() {
        super.onResume();
        try {
            myAppAdapter.notifyDataSetChanged();
        } catch (Exception e) {
            try {
                myGameAdapter.notifyDataSetChanged();
            } catch (Exception e1) {
                e1.printStackTrace();
            }
            e.printStackTrace();
        }
    }

    //根据包名获取版本号,写在activity/fragment层
    @Override
    public Integer getVersionNo(String packageName){
        return ApkUtil.getInstalledApkVersionNo(getActivity(),packageName);
    }

    //注销文件下载监听
    @Override
    public void onDestroy() {
        super.onDestroy();
        rankListPresenter.unregisterListener();
    }

//#########################################################################################
第三步、注册监听器（如果不需要监听，可以忽略），监听器是基于观察者模式设计的全局监听器，可以设置多个，记得在不需要的时候取消注册
注册下载状态监听器(一般在fragment或activity的onCreate方法中注册，如果你使用service，请查看在Service中使用FileDownloader):
https://github.com/wlfcolin/file-downloader/blob/master/USEINSERVICE-zh.md


    //设置文件下载监听(p层中)(也可以用adapter implements OnFileDownloadStatusListener(or OnRetryableFileDownloadStatusListener))
    public void setFileDownloadListener() {
        FileDownloader.registerDownloadStatusListener(mOnFileDownloadStatusListener);
    }

    private OnFileDownloadStatusListener mOnFileDownloadStatusListener = new
            OnSimpleFileDownloadStatusListener() {
                @Override
                public void onFileDownloadStatusRetrying(DownloadFileInfo downloadFileInfo, int
                        retryTimes) {
                    // 正在重试下载（如果你配置了重试次数，当一旦下载失败时会尝试重试下载），retryTimes是当前第几次重试
                    //true:是否需要安装apk,因为fragment中的onResume也要调用这个方法更新显示,到时候传false
                    iRankListView.notifyItemChange(downloadFileInfo,true);
                }

                @Override
                public void onFileDownloadStatusWaiting(DownloadFileInfo downloadFileInfo) {
                    // 等待下载（等待其它任务执行完成，或者FileDownloader在忙别的操作）
                    iRankListView.notifyItemChange(downloadFileInfo,true);
                }

                @Override
                public void onFileDownloadStatusPreparing(DownloadFileInfo downloadFileInfo) {
                    // 准备中（即，正在连接资源）
                    iRankListView.notifyItemChange(downloadFileInfo,true);
                }

                @Override
                public void onFileDownloadStatusPrepared(DownloadFileInfo downloadFileInfo) {
                    // 已准备好（即，已经连接到了资源）
                    iRankListView.notifyItemChange(downloadFileInfo,true);
                }

                @Override
                public void onFileDownloadStatusDownloading(DownloadFileInfo downloadFileInfo, float
                        downloadSpeed, long
                                                                    remainingTime) {
                    // 正在下载，downloadSpeed为当前下载速度，单位KB/s，remainingTime为预估的剩余时间，单位秒
                    iRankListView.notifyItemChange(downloadFileInfo,true);
                }

                @Override
                public void onFileDownloadStatusPaused(DownloadFileInfo downloadFileInfo) {
                    // 下载已被暂停
                    iRankListView.notifyItemChange(downloadFileInfo,true);
                }

                @Override
                public void onFileDownloadStatusCompleted(DownloadFileInfo downloadFileInfo) {
                    // 下载完成（整个文件已经全部下载完成）
                    iRankListView.notifyItemChange(downloadFileInfo,true);
                }

                @Override
                public void onFileDownloadStatusFailed(String url, DownloadFileInfo
                        downloadFileInfo,
                                                       FileDownloadStatusFailReason failReason) {
                    // 下载失败了，详细查看失败原因failReason，有些失败原因你可能必须关心

                    String failType = failReason.getType();
                    String failUrl = failReason.getUrl();// 或：failUrl = url，url和failReason.getUrl
                    // ()会是一样的

                    iRankListView.notifyItemChange(downloadFileInfo,true);

                    if (FileDownloadStatusFailReason.TYPE_URL_ILLEGAL.equals(failType)) {
                        // 下载failUrl时出现url错误

                    } else if (FileDownloadStatusFailReason.TYPE_STORAGE_SPACE_IS_FULL.equals
                            (failType)) {
                        // 下载failUrl时出现本地存储空间不足
                        //                        tvProgress.setText("存储卡已满");
                    } else if (FileDownloadStatusFailReason.TYPE_NETWORK_DENIED.equals(failType)) {
                        // 下载failUrl时出现无法访问网络
                        //                        tvProgress.setText("请检查网络");

                    } else if (FileDownloadStatusFailReason.TYPE_NETWORK_TIMEOUT.equals(failType)) {
                        // 下载failUrl时出现连接超时
                        //                        tvProgress.setText("请检查网络");

                    } else {
                        // 更多错误....
                    }

                    // 查看详细异常信息
                    Throwable failCause = failReason.getCause();// 或：failReason.getOriginalCause()

                    // 查看异常描述信息
                    String failMsg = failReason.getMessage();// 或：failReason.getOriginalCause()
                    // .getMessage()
                }
            };


    //needInstallApk作用:当下载完成后需要安装,当onResume安装完成后更新显示.写在activity/fragment中
    @Override
    public void notifyItemChange(DownloadFileInfo downloadFileInfo, boolean needInstallApk) {
        if (downloadFileInfo != null) {
            String url = downloadFileInfo.getUrl();
            if (url != null) {
                for (int i = 0; i < appUrls.size(); i++) {
                    if (url.equals(appUrls.get(i))) {
                        myAppAdapter.notifyItemChanged(i);
                        //如果下载完成就安装
                        if (downloadFileInfo.getStatus() == Status.DOWNLOAD_STATUS_COMPLETED) {
                            if (needInstallApk) {
                                installApk(downloadFileInfo);
                                rankListPresenter.saveDownloadLog(appData.get(i).appId, appData.get
                                        (i).versionNo);//保存下载记录
                            }
                        }
                        return;
                    }
                }
                for (int i = 0; i < gameUrls.size(); i++) {
                    if (url.equals(gameUrls.get(i))) {
                        myGameAdapter.notifyItemChanged(i);
                        //如果下载完成就安装
                        if (downloadFileInfo.getStatus() == Status.DOWNLOAD_STATUS_COMPLETED) {
                            installApk(downloadFileInfo);
                            rankListPresenter.saveDownloadLog(gameData.get(i).appId, gameData.get
                                    (i).versionNo);//保存下载记录
                        }
                    }
                }
            }
        }
    }

    //注销监听(写在p层)
    public void unregisterListener() {
        if (mOnFileDownloadStatusListener != null) {
            FileDownloader.unregisterDownloadStatusListener(mOnFileDownloadStatusListener);
        }
    }



//#########################################################################################
注册文件数据变化监听器，监听比如文件不存在了，被删除了，状态变化了等任何与文件数据变化相关都会收到通知
private OnDownloadFileChangeListener mOnDownloadFileChangeListener = new OnDownloadFileChangeListener() {
    @Override
    public void onDownloadFileCreated(DownloadFileInfo downloadFileInfo) {
        // 一个新下载文件被创建，也许你需要同步你自己的数据存储，比如在你的业务数据库中增加一条记录
    }
    @Override
    public void onDownloadFileUpdated(DownloadFileInfo downloadFileInfo, Type type) {
        // 一个下载文件被更新，也许你需要同步你自己的数据存储，比如在你的业务数据库中更新一条记录
    }
    @Override
    public void onDownloadFileDeleted(DownloadFileInfo downloadFileInfo) {
        // 一个下载文件被删除，也许你需要同步你自己的数据存储，比如在你的业务数据库中删除一条记录
    }
};
FileDownloader.registerDownloadFileChangeListener(mOnDownloadFileChangeListener);

下载状态监听器和文件数据变化监听器的主要区别在于，前者关心下载进度和错误（前端UI），后者关心文件数据变化（数据存储）


//#########################################################################################
删除已经下载完成的文件(本例删除失败,不知道是什么原因)
List<DownloadFileInfo> downloadFiles = FileDownloader.getDownloadFiles();
                for (int i = 0; i < downloadFiles.size(); i++) {
                    switch (downloadFiles.get(i).getStatus()) {
                    case Status.DOWNLOAD_STATUS_COMPLETED://如果下载完成了,如果不做判断,正在下载/暂停的都会被删掉
                        FileDownloader.delete(downloadFiles.get(i).getUrl(), true, new OnDeleteDownloadFileListener() {

                            @Override
                            public void onDeleteDownloadFilePrepared(DownloadFileInfo downloadFileNeedDelete) {

                            }

                            @Override
                            public void onDeleteDownloadFileSuccess(DownloadFileInfo downloadFileDeleted) {
                                ToastUtils.show(getActivity(),"删除完成!");
                            }

                            @Override
                            public void onDeleteDownloadFileFailed(DownloadFileInfo downloadFileInfo, DeleteDownloadFileFailReason failReason) {

                            }
                        });
                        break;
                    default:
                        break;
                    }
                }


由于本例删除失败,用的下面这个方法
                    if (deleteFile(apkPaths.get(position))) {
                        appInfos.remove(position);
                        apkPaths.remove(position);
                        myDownloadApkAdapter.notifyDataSetChanged();
                        ToastUtils.show(APKManagerActivity.this, "删除成功!");
                    } else {
                        ToastUtils.show(APKManagerActivity.this, "删除失败!");
                    }
    /**
     * 删除单个文件
     *
     * @param filePath 被删除文件的文件名
     * @return 文件删除成功返回true，否则返回false
     */
    public boolean deleteFile(String filePath) {
        File file = new File(filePath);
        if (file.isFile() && file.exists()) {
            return file.delete();
        }
        return false;
    }


//#########################################################################################
创建一个自定义保存路径和文件名称的下载
FileDownloader.detect(url, new OnDetectBigUrlFileListener() {
    @Override
    public void onDetectNewDownloadFile(String url, String fileName, String saveDir, long fileSize) {
        // 如果有必要，可以改变文件名称fileName和下载保存的目录saveDir
        FileDownloader.createAndStart(url, newFileDir, newFileName);
    }
    @Override
    public void onDetectUrlFileExist(String url) {
        // 继续下载，自动会断点续传（如果服务器无法支持断点续传将从头开始下载）
        FileDownloader.start(url);
    }
    @Override
    public void onDetectUrlFileFailed(String url, DetectBigUrlFileFailReason failReason) {
        // 探测一个网络文件失败了，具体查看failReason
    }
});


//#########################################################################################
暂停下载
FileDownloader.pause(url);// 暂停单个下载任务
FileDownloader.pause(urls);// 暂停多个下载任务
FileDownloader.pauseAll();// 暂停所有下载任务


继续下载
FileDownloader.start(url);// 继续下载，自动会断点续传（如果服务器无法支持断点续传将从头开始下载）



移动下载文件
FileDownloader.move(url, newDirPath, mOnMoveDownloadFileListener);// 移动单个下载文件到新文件夹中
FileDownloader.move(urls, newDirPath, mOnMoveDownloadFilesListener);// 移动多个下载文件到新文件夹中



删除下载文件
FileDownloader.delete(url, true, mOnDeleteDownloadFileListener);// 删除单个下载文件
FileDownloader.delete(urls, true, mOnDeleteDownloadFilesListener);// 删除多个下载文件



重命名下载文件
FileDownloader.rename(url, newName, true, mOnRenameDownloadFileListener);// 重命名一个下载文件


开始全部下载任务
FileDownloader.continueAll(true);


//#########################################################################################
第五步、取消注册的监听器
-取消注册下载状态监听器(一般在fragment或activity的onDestroy方法中取消注册)
FileDownloader.unregisterDownloadStatusListener(mOnFileDownloadStatusListener);



取消注册文件数据变化监听器
FileDownloader.unregisterDownloadFileChangeListener(mOnDownloadFileChangeListener);



五、详细API文档
http://htmlpreview.github.io/?https://raw.githubusercontent.com/wlfcolin/file-downloader/master/download/release/FileDownloader-0.3.2-javadoc/index.html


