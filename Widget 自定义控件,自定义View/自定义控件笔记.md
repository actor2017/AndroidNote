# 自定义控件笔记 #

# Day01 #

## 系统控件回顾 ##

文本控件	TextView和EditText

图片控件	ImageView

按钮控件	Button和ImageButton

进度条	ProgressBar

单选按钮	RadioButton和RadioGroup

复选按钮	CheckBox

状态开关按钮ToggleButton

父控件 ViewGroup(LinearLayout, RelativeLayout, FrameLayout)

时钟控件	AnalogClock和DigitalClock

日期与时间选择控件DatePicker和TimePicker等

> 梳理继承关系

## 优酷菜单开发 ##

- 布局文件开发
	
		<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
	    xmlns:tools="http://schemas.android.com/tools"
	    android:layout_width="match_parent"
	    android:layout_height="match_parent" >
	
	    <RelativeLayout
	        android:id="@+id/rl_level3"
	        android:layout_width="280dp"
	        android:layout_height="140dp"
	        android:layout_alignParentBottom="true"
	        android:layout_centerHorizontal="true"
	        android:background="@drawable/level3" >
	
	        <ImageView
	            android:id="@+id/iv_channel1"
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:layout_alignParentBottom="true"
	            android:layout_margin="10dp"
	            android:src="@drawable/channel1" />
	
	        <ImageView
	            android:id="@+id/iv_channel2"
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:layout_above="@id/iv_channel1"
	            android:layout_alignLeft="@id/iv_channel1"
	            android:layout_marginBottom="5dp"
	            android:layout_marginLeft="25dp"
	            android:src="@drawable/channel2" />
	
	        <ImageView
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:layout_above="@id/iv_channel2"
	            android:layout_alignLeft="@id/iv_channel2"
	            android:layout_marginBottom="3dp"
	            android:layout_marginLeft="33dp"
	            android:src="@drawable/channel3" />
	
	        <ImageView
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:layout_centerHorizontal="true"
	            android:layout_margin="10dp"
	            android:src="@drawable/channel4" />
	
	        <ImageView
	            android:id="@+id/iv_channel7"
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:layout_alignParentBottom="true"
	            android:layout_alignParentRight="true"
	            android:layout_margin="10dp"
	            android:src="@drawable/channel7" />
	
	        <ImageView
	            android:id="@+id/iv_channel6"
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:layout_above="@id/iv_channel7"
	            android:layout_alignRight="@id/iv_channel7"
	            android:layout_marginBottom="5dp"
	            android:layout_marginRight="25dp"
	            android:src="@drawable/channel6" />
	
	        <ImageView
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:layout_above="@id/iv_channel6"
	            android:layout_alignRight="@id/iv_channel6"
	            android:layout_marginBottom="3dp"
	            android:layout_marginRight="33dp"
	            android:src="@drawable/channel5" />
	    </RelativeLayout>
	
	    <RelativeLayout
	        android:id="@+id/rl_level2"
	        android:layout_width="180dp"
	        android:layout_height="90dp"
	        android:layout_alignParentBottom="true"
	        android:layout_centerHorizontal="true"
	        android:background="@drawable/level2" >
	
	        <ImageView
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:layout_alignParentBottom="true"
	            android:layout_margin="10dp"
	            android:src="@drawable/icon_search" />
	
	        <ImageView
	            android:id="@+id/iv_menu"
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:layout_alignParentTop="true"
	            android:layout_centerHorizontal="true"
	            android:layout_marginTop="5dp"
	            android:src="@drawable/icon_menu" />
	
	        <ImageView
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:layout_alignParentBottom="true"
	            android:layout_alignParentRight="true"
	            android:layout_margin="10dp"
	            android:src="@drawable/icon_myyouku" />
	    </RelativeLayout>
	
	    <RelativeLayout
	        android:id="@+id/rl_level1"
	        android:layout_width="100dp"
	        android:layout_height="50dp"
	        android:layout_alignParentBottom="true"
	        android:layout_centerHorizontal="true"
	        android:background="@drawable/level1" >
	
	        <ImageView
	            android:id="@+id/iv_home"
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:layout_centerHorizontal="true"
	            android:layout_centerVertical="true"
	            android:src="@drawable/icon_home" />
	    </RelativeLayout>
	
	</RelativeLayout>

- 点击事件响应

		ivHome = (ImageView) findViewById(R.id.iv_home);
		ivMenu = (ImageView) findViewById(R.id.iv_menu);
		
		ivHome.setOnClickListener(this);
		ivMenu.setOnClickListener(this);

		@Override
		public void onClick(View v) {
				switch (v.getId()) {
				case R.id.iv_home:
					System.out.println("home");
					break;
				case R.id.iv_menu:
					System.out.println("menu");
					break;
				default:
					break;
				}
			}
		
- 事件细节处理

		第三层相对布局盖住了第二层布局, 第二层盖住了第一层, 如果给第三层设置点击事件, 那么第一层和第二层都无法再响应事件了.

		rlLevel3.setOnClickListener(this);

		解决方法:
		修改布局文件位置, 先写第三层布局,再写第二层, 最后写第一层, 这样可以保证第一层布局在最上面, 第三层在最下面, 那么第三层布局就不能挡住第一层和第二层的点击事件了.	

- 动画工具类开发

		package com.itheima.youkuteach;

		import android.view.ViewGroup;
		import android.view.animation.Animation;
		import android.view.animation.RotateAnimation;
		
		/**
		 * 处理动画的工具类
		 * 
		 * @author Kevin
		 * 
		 */
		public class Tools {
		
			public static void hideView(ViewGroup view) {
				hideView(view, 0);
			}
		
			public static void showView(ViewGroup view) {
				showView(view, 0);
			}
		
			/**
			 * 隐藏布局
			 * 
			 * @param view
			 */
			public static void hideView(ViewGroup view, long delayTime) {
				RotateAnimation anim = new RotateAnimation(0, 180,
						Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 1);
				anim.setDuration(500);// 动画执行时间
				anim.setFillAfter(true);// 保持动画结束的状态
				anim.setStartOffset(delayTime);// 延时执行动画
				view.startAnimation(anim);
		
				// 让父控件的所有子控件在不显示的时候无法点击
				for (int i = 0; i < view.getChildCount(); i++) {
					view.getChildAt(i).setEnabled(false);// 禁用点击事件
				}
			}
		
			/**
			 * 显示布局
			 * 
			 * @param view
			 */
			public static void showView(ViewGroup view, long delayTime) {
				RotateAnimation anim = new RotateAnimation(180, 360,
						Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 1);
				anim.setDuration(500);// 动画执行时间
				anim.setFillAfter(true);// 保持动画结束的状态
				anim.setStartOffset(delayTime);// 延时执行动画
				view.startAnimation(anim);
		
				for (int i = 0; i < view.getChildCount(); i++) {
					view.getChildAt(i).setEnabled(true);// 开启点击事件
				}
			}
		}	

- 主页面开发

		package com.itheima.youkuteach;
		
		import android.app.Activity;
		import android.os.Bundle;
		import android.view.KeyEvent;
		import android.view.View;
		import android.view.View.OnClickListener;
		import android.widget.ImageView;
		import android.widget.RelativeLayout;
		
		public class MainActivity extends Activity implements OnClickListener {
		
			private RelativeLayout rlLevel1;
			private RelativeLayout rlLevel2;
			private RelativeLayout rlLevel3;
		
			private ImageView ivHome;
			private ImageView ivMenu;
		
			/**
			 * 判断第一级菜单 是否显示。 true 为显示 false 为隐藏
			 */
			private boolean isShowLevel1 = true;
		
			/**
			 * 判断第二级菜单 是否显示。 true 为显示 false 为隐藏
			 */
			private boolean isShowLevel2 = true;
		
			/**
			 * 判断第三级菜单 是否显示。 true 为显示 false 为隐藏
			 */
			private boolean isShowLevel3 = true;
		
			@Override
			protected void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.activity_main);
		
				rlLevel1 = (RelativeLayout) findViewById(R.id.rl_level1);
				rlLevel2 = (RelativeLayout) findViewById(R.id.rl_level2);
				rlLevel3 = (RelativeLayout) findViewById(R.id.rl_level3);
		
				ivHome = (ImageView) findViewById(R.id.iv_home);
				ivMenu = (ImageView) findViewById(R.id.iv_menu);
		
				ivHome.setOnClickListener(this);
				ivMenu.setOnClickListener(this);
			}
		
			@Override
			public void onClick(View v) {
				switch (v.getId()) {
				case R.id.iv_home:
					System.out.println("home");
					if (isShowLevel2) {
						// 隐藏二级菜单
						Tools.hideView(rlLevel2);
						isShowLevel2 = false;
		
						if (isShowLevel3) {
							// 隐藏三级菜单
							Tools.hideView(rlLevel3, 200);
							isShowLevel3 = false;
						}
					} else {
						// 显示二级菜单
						Tools.showView(rlLevel2);
						isShowLevel2 = true;
					}
					break;
				case R.id.iv_menu:
					System.out.println("menu");
					if (isShowLevel3) {
						// 隐藏三级菜单
						Tools.hideView(rlLevel3);
						isShowLevel3 = false;
					} else {
						// 显示三级菜单
						Tools.showView(rlLevel3);
						isShowLevel3 = true;
					}
					break;
				default:
					break;
				}
			}
		}

- 拦截物理菜单键

		@Override
		public boolean onKeyDown(int keyCode, KeyEvent event) {
			if (keyCode == KeyEvent.KEYCODE_MENU) {// 拦截物理菜单键
				if (isShowLevel1) {// 如果一级菜单显示, 则隐藏所有菜单
					Tools.hideView(rlLevel1);
					isShowLevel1 = false;
	
					if (isShowLevel2) {
						Tools.hideView(rlLevel2, 200);
						isShowLevel2 = false;
					}
	
					if (isShowLevel3) {
						Tools.hideView(rlLevel3, 300);
						isShowLevel3 = false;
					}
				} else {// 如果一级菜单隐藏, 则显示一级菜单和二级菜单
					Tools.showView(rlLevel1);
					isShowLevel1 = true;
	
					Tools.showView(rlLevel2, 200);
					isShowLevel2 = true;
				}
				return true;
			}
			return super.onKeyDown(keyCode, event);
		}

## 广告条开发 ##

- ViewPager介绍
- ViewPager源码绑定

		选中项目,点右键->Build Path->Configure Build Path->Libraries->删除support v4包->Add Jars(重新添加support v4包)->Order And Export->勾选support v4包->进入ViewPager的类中, 点击Attach Source按钮, 绑定源码

- ViewPager的基本使用

	1. 布局文件

			<android.support.v4.view.ViewPager
	       		 android:id="@+id/vp"
	       	 	 android:layout_width="wrap_content"
	        	 android:layout_height="wrap_content" />


	2. 数据适配器

			/**
			 * ViewPager的数据适配器
			 * 
			 * @author Kevin
			 * 
			 */
			class MyPagerAdapter extends PagerAdapter {
		
				/**
				 * item的数量
				 */
				@Override
				public int getCount() {
					return mImageIds.length;
				}
		
				/**
				 * 判断要绘制的view和object之间的联系 object: 就是instantiateItem返回的object
				 */
				@Override
				public boolean isViewFromObject(View view, Object object) {
					return view == object;
				}
		
				/**
				 * 初始化布局
				 */
				@Override
				public Object instantiateItem(ViewGroup container, int position) {
					System.out.println("instantiateItem:" + position);
					ImageView view = new ImageView(getApplicationContext());
					view.setImageResource(mImageIds[position]);
					container.addView(view);
					return view;
				}
		
				/**
				 * 销毁特定位置上的view object: 就是instantiateItem返回的object
				 */
				@Override
				public void destroyItem(ViewGroup container, int position, Object object) {
					System.out.println("destroyItem:" + position);
					container.removeView((View) object);
				}
			}

	3. 初始化ViewPager
	
			mViewPager = (ViewPager) findViewById(R.id.vp);
			MyPagerAdapter adapter = new MyPagerAdapter();
			mViewPager.setAdapter(adapter);

- ViewPager循环拖动

		1. 将ViewPager的孩子个数改为Int的最大值

			/**
			 * item的数量
			 */
			@Override
			public int getCount() {
				//return mImageIds.length;
				return Integer.MAX_VALUE;
			}

			如果1秒钟滑动一页的话,需要69年才能够划完, 所以Int的最大值可以基本保证无限循环

		2. 修改初始化布局的方法

			/**
			 * 初始化布局
			 */
			@Override
			public Object instantiateItem(ViewGroup container, int position) {
				System.out.println("instantiateItem:" + position);
				ImageView view = new ImageView(getApplicationContext());
				view.setImageResource(mImageIds[position%mImageIds.length]);//此处应该是当前位置对item个数的取余结果
				container.addView(view);
				return view;
			}

		3. 初始化完成后,viewPager展示第一页item, 所以只能向右滑动,无法向左滑动, 为了保证一开始就可以向左滑动,可以设定开始位置为比较大的值,比如:

			mViewPager.setCurrentItem(mImageIds.length * 10000);


- ViewPager增加标题展示

		1. 布局文件

		<FrameLayout
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:layout_centerVertical="true" >
	
	        <android.support.v4.view.ViewPager
	            android:id="@+id/vp"
	            android:layout_width="match_parent"
	            android:layout_height="180dp" />
	
	        <LinearLayout
	            android:layout_width="match_parent"
	            android:layout_height="wrap_content"
	            android:layout_gravity="bottom"
	            android:background="#a000"
	            android:orientation="vertical" >
	
	            <TextView
	                android:id="@+id/tv_title"
	                android:layout_width="match_parent"
	                android:layout_height="wrap_content"
	                android:padding="5dp"
	                android:text="标题"
	                android:textColor="#fff"
	                android:textSize="16sp" />
	        </LinearLayout>
	    </FrameLayout>

		2. ViewPager设置滑动监听
		
		// 图片标题集合
		private final String[] mImageDes = { "巩俐不低俗，我就不能低俗", "朴树又回来啦！再唱经典老歌引万人大合唱","揭秘北京电影如何升级", "乐视网TV版大派送", "热血屌丝的反杀" };

		// 设置滑动监听
		mViewPager.setOnPageChangeListener(new OnPageChangeListener() {

			// 某一页被选中时调用
			@Override
			public void onPageSelected(int position) {
				// 更新标题内容
				tvTitle.setText(mImageDes[position % mImageDes.length]);
			}

			// 滑动时调用
			@Override
			public void onPageScrolled(int position, float positionOffset,
					int positionOffsetPixels) {

			}

			// 滑动状态发生变化
			@Override
			public void onPageScrollStateChanged(int state) {

			}
		});

		3. 保证图片宽高填充ImageView

			view.setScaleType(ScaleType.FIT_XY);//图片宽高填充父窗体

- ViewPager增加位置指示器

		1. 布局文件中写一个空的线性布局   
		 	
			<LinearLayout
                android:id="@+id/ll_container"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="3dp"
                android:gravity="center"
                android:orientation="horizontal" >
            </LinearLayout>

		2. 使用shape绘制小圆点

			shape_point_default.xml
			
			<?xml version="1.0" encoding="utf-8"?>
			<shape xmlns:android="http://schemas.android.com/apk/res/android"
			    android:shape="oval" >
			
			    <size
			        android:height="5dp"
			        android:width="5dp" />
			
			    <solid android:color="#5fff" />
			
			</shape>

			------------------------------------

			shape_point_selected.xml

			<?xml version="1.0" encoding="utf-8"?>
			<shape xmlns:android="http://schemas.android.com/apk/res/android"
			    android:shape="oval" >
			
			    <size
			        android:height="5dp"
			        android:width="5dp" />
			
			    <solid android:color="#f00" />
			
			</shape>

			-----------------------------------

			point_selecter.xml

			<?xml version="1.0" encoding="utf-8"?>
			<selector xmlns:android="http://schemas.android.com/apk/res/android">
			
			    <item android:drawable="@drawable/shape_point_selected" android:state_enabled="true"/>
			    <item android:drawable="@drawable/shape_point_default" android:state_enabled="false"/>
			
			</selector>
			

		3. 初始化小圆点

			for (int i = 0; i < mImageIds.length; i++) {
				ImageView ivPoint = new ImageView(this);
				ivPoint.setImageResource(R.drawable.point_selecter);
	
				// 默认第一个圆点选中,其他不选中
				if (i != 0) {
					ivPoint.setEnabled(false);
				} else {
					ivPoint.setEnabled(true);
				}
	
				// 初始化布局参数
				LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT,
						LayoutParams.WRAP_CONTENT);
	
				if (i != 0) {
					params.leftMargin = 5;// 增加圆点之间的边距
				}
	
				ivPoint.setLayoutParams(params);// 设置布局参数
				llContainer.addView(ivPoint);// 给线性布局添加孩子
			}

		4. 滑动ViewPager时, 更新小圆点的展示

			// 某一页被选中时调用
			@Override
			public void onPageSelected(int position) {
				int pos = position % mImageDes.length;// 获取图片位置

				// 更新标题内容
				tvTitle.setText(mImageDes[pos]);

				// 将当前圆点设置为选中状态
				ImageView ivPoint = (ImageView) llContainer.getChildAt(pos);
				ivPoint.setEnabled(true);

				// 将上一个圆点设置为不选中状态
				llContainer.getChildAt(mLastPointPos).setEnabled(false);

				// 重新设置上次圆点的位置
				mLastPointPos = pos;
			}

- ViewPager实现页面自动切换

		//此Handler专门处理轮播条的自动切换
		private Handler mHandler = new Handler() {
			public void handleMessage(android.os.Message msg) {
				int currentItem = mViewPager.getCurrentItem();
				mViewPager.setCurrentItem(++currentItem);// 设置当前页面为下一页
	
				mHandler.sendEmptyMessageDelayed(0, 3000);// 延时3秒后发送消息,自动更新轮播条位置
			};
		};

		// 延时3秒后发送消息,自动更新轮播条位置
		mHandler.sendEmptyMessageDelayed(0, 3000);

- ViewPager事件处理

		当手动滑动轮播条时, 页面还是会自动切换. 可以改动为, 手动触摸轮播条时停止切换, 手松开后再继续切换.

		// 设置触摸监听
		mViewPager.setOnTouchListener(new OnTouchListener() {

			@Override
			public boolean onTouch(View v, MotionEvent event) {
				switch (event.getAction()) {
				case MotionEvent.ACTION_DOWN:
					System.out.println("ACTION_DOWN");
					mHandler.removeCallbacksAndMessages(null);// 删除所有消息,停止广告条自动切换
					break;
				case MotionEvent.ACTION_UP:
					System.out.println("ACTION_UP");
					mHandler.sendEmptyMessageDelayed(0, 3000);// 继续自动切换广告条
					break;

				default:
					break;
				}

				return false;// 这里需要返回false, 不能消耗掉事件,
								// 这样的话ViewPager才能够响应触摸滑动的事件,页面跟随手指移动
			}
		});

## 下拉框 ##

	- 布局文件开发

		<RelativeLayout
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:layout_alignParentTop="true"
	        android:layout_centerHorizontal="true"
	        android:layout_marginTop="152dp" >
	
	        <EditText
	            android:id="@+id/et_input"
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:ems="10" >
	        </EditText>
	
	        <ImageView
	            android:id="@+id/iv_down"
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:layout_alignRight="@id/et_input"
	            android:src="@drawable/down_arrow" />
	    </RelativeLayout>

	- 相关代码

		public class MainActivity extends Activity {

			private EditText etInput;
			private ImageView ivDown;
		
			private ArrayList<String> mList;
			private PopupWindow mPopupWindow;
			private ListView lvList;
		
			@Override
			protected void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.activity_main);
				etInput = (EditText) findViewById(R.id.et_input);
				ivDown = (ImageView) findViewById(R.id.iv_down);
		
				ivDown.setOnClickListener(new OnClickListener() {
		
					@Override
					public void onClick(View v) {
						showPopup();
					}
				});
		
				// 初始化下拉列表数据
				mList = new ArrayList<String>();
				for (int i = 0; i < 200; i++) {
					mList.add("aaabbbccc" + i);
				}
		
				// 初始化listview
				lvList = new ListView(this);
				lvList.setAdapter(new MyAdapter());
		
				lvList.setOnItemClickListener(new OnItemClickListener() {
		
					@Override
					public void onItemClick(AdapterView<?> parent, View view,
							int position, long id) {
						String text = mList.get(position);
						etInput.setText(text);
		
						mPopupWindow.dismiss();
					}
				});
			}
		
			/**
			 * 展现下拉框
			 */
			protected void showPopup() {
				if (mPopupWindow == null) {
					mPopupWindow = new PopupWindow(lvList, etInput.getWidth(), 200,
							true);
					mPopupWindow.setBackgroundDrawable(new ColorDrawable());
				}
		
				mPopupWindow.showAsDropDown(etInput);//展现在文本框的正下方
			}
		
			class MyAdapter extends BaseAdapter {
		
				@Override
				public int getCount() {
					return mList.size();
				}
		
				@Override
				public String getItem(int position) {
					return mList.get(position);
				}
		
				@Override
				public long getItemId(int position) {
					return position;
				}
		
				@Override
				public View getView(final int position, View convertView,
						ViewGroup parent) {
					ViewHolder holder;
					if (convertView == null) {
						convertView = View.inflate(getApplicationContext(),
								R.layout.list_item, null);
						holder = new ViewHolder();
						holder.tvText = (TextView) convertView
								.findViewById(R.id.tv_text);
						holder.ivDelete = (ImageView) convertView
								.findViewById(R.id.iv_delete);
						convertView.setTag(holder);
					} else {
						holder = (ViewHolder) convertView.getTag();
					}
		
					// TextView view = new TextView(getApplicationContext());
					// String text = getItem(position);
					// view.setText(text);
		
					holder.tvText.setText(getItem(position));
					holder.ivDelete.setOnClickListener(new OnClickListener() {
		
						@Override
						public void onClick(View v) {
							//删除当前被点击的元素,并刷新listview
							mList.remove(position);
							MyAdapter.this.notifyDataSetChanged();
						}
					});
		
					return convertView;
				}
		
			}
		
			static class ViewHolder {
				public TextView tvText;
				public ImageView ivDelete;
			}
		}

## 自定义开关 ##

- 创建自定义View

		/**
		 * 自定义开关
		 * 
		 * @author Kevin
		 * 
		 */
		public class MySwitch extends View {

			// 代码初始化
			public MySwitch(Context context) {
				super(context);
				init();
			}
		
			// 布局文件初始化,带属性和样式
			public MySwitch(Context context, AttributeSet attrs, int defStyle) {
				super(context, attrs, defStyle);
				init();
			}
		
			// 布局文件初始化, 带属性
			public MySwitch(Context context, AttributeSet attrs) {
				super(context, attrs);
				init();
			}
		}

- 重写onDraw方法, 绘制矩形

		@Override
		protected void onDraw(Canvas canvas) {
			System.out.println("onDraw");
			canvas.drawRect(0, 0, 200, 200, mPaint);//绘制矩形
		}

- 重新onMeasure方法, 修改控件大小

		@Override
		protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
			System.out.println("onMeasure");
			setMeasuredDimension(50, 50);
		}

		注意: onMeasure先于onDraw调用, 最终绘制大小以onMeasure设置的大小为准

- 绘制自定义开关的两张图片,修改滑块位置,展示开关效果

		/**
		 * 初始化
		 */
		private void init() {
			// 初始化画笔对象
			mPaint = new Paint();
			mPaint.setColor(Color.RED);
	
			// 初始化图片对象
			mBitmapBg = BitmapFactory.decodeResource(getResources(),
					R.drawable.switch_background);
			mBitmapSlide = BitmapFactory.decodeResource(getResources(),
					R.drawable.slide_button);
	
			// 计算滑块最大左边距
			MAX_LEFT = mBitmapBg.getWidth() - mBitmapSlide.getWidth();
		}

		@Override
		protected void onDraw(Canvas canvas) {
			System.out.println("onDraw");
			canvas.drawBitmap(mBitmapBg, 0, 0, mPaint);// 绘制图片
			canvas.drawBitmap(mBitmapSlide, 0, 0, mPaint);//修改参2值为0或者MAX_LEFT, 展示开关效果
		}

- 点击事件处理(点击后切换开关展示)

		private int mSlideLeft;// 滑块左边距
		private boolean isOpen;// true表示开关已打开, false表示已关闭

		setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View v) {
				if (isOpen) {
					isOpen = false;
					mSlideLeft = 0;
				} else {
					isOpen = true;
					mSlideLeft = MAX_LEFT;
				}

				invalidate();// 刷新view, 会重新调用onDraw方法
			}
		});

		canvas.drawBitmap(mBitmapSlide, mSlideLeft, 0, mPaint);

- 自定义回调接口,响应开关切换事件

		对比CheckBox的开关事件, 给自定义View设置类似的事件监听.

		private OnCheckedChangeListener mListener;

		/**
		 * 开关切换事件的回调接口
		 */
		public interface OnCheckedChangeListener {
			public void onCheckedChanged(MySwitch view, boolean isChecked);
		}
	
		/**
		 * 设置开关切换的事件监听
		 */
		public void setOnCheckedChangeListener(OnCheckedChangeListener listener) {
			mListener = listener;
		}

		//在OnClick事件中调用接口方法
		if (mListener != null) {
				mListener.onCheckedChanged(MySwitch.this, isOpen);
		}

		//在MainActivity设置事件监听
		MySwitch s = (MySwitch) findViewById(R.id.my_switch);
		s.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(MySwitch view, boolean isChecked) {
				System.out.println("开关状态:" + isChecked);
			}
		});

- 滑动事件处理

		int startX;//起始x坐标
	
		@Override
		public boolean onTouchEvent(MotionEvent event) {
			switch (event.getAction()) {
			case MotionEvent.ACTION_DOWN:
				startX = (int) event.getX();
				break;
			case MotionEvent.ACTION_MOVE:
				int endX = (int) event.getX();
				int dx = endX - startX;
	
				mSlideLeft += dx;//根据x坐标移动偏移量,计算最新的左边距值
	
				//修正移动位置,避免过于偏左
				if (mSlideLeft < 0) {
					mSlideLeft = 0;
				}
	
				//修正移动位置,避免过于偏右
				if (mSlideLeft > MAX_LEFT) {
					mSlideLeft = MAX_LEFT;
				}
	
				//刷新view
				invalidate();
	
				//重新初始化起始点坐标
				startX = (int) event.getX();
	
				break;
	
			case MotionEvent.ACTION_UP:
				//手指抬起后,根据当前滑块位置,确定开关状态
				if (mSlideLeft > MAX_LEFT / 2) {//打开状态
					mSlideLeft = MAX_LEFT;
					isOpen = true;
				} else {//关闭状态
					mSlideLeft = 0;
					isOpen = false;
				}
	
				invalidate();//刷新
	
				//开关切换事件的回调方法
				if (mListener != null) {
					mListener.onCheckedChanged(MySwitch.this, isOpen);
				}
				break;
	
			default:
				break;
			}
	
			return true;//消耗掉事件
		}

- 同时响应点击事件和触摸事件

		boolean isClick;// 表示当前是否可以响应点击事件

		@Override
		public boolean onTouchEvent(MotionEvent event) {
			switch (event.getAction()) {
			case MotionEvent.ACTION_DOWN:
				startX = (int) event.getX();
				break;
			case MotionEvent.ACTION_MOVE:
				int endX = (int) event.getX();
				int dx = endX - startX;
	
				mMoveX += Math.abs(dx);// 计算移动距离
	
				mSlideLeft += dx;// 根据x坐标移动偏移量,计算最新的左边距值
	
				// 修正移动位置,避免过于偏左
				if (mSlideLeft < 0) {
					mSlideLeft = 0;
				}
	
				// 修正移动位置,避免过于偏右
				if (mSlideLeft > MAX_LEFT) {
					mSlideLeft = MAX_LEFT;
				}
	
				// 刷新view
				invalidate();
	
				// 重新初始化起始点坐标
				startX = (int) event.getX();
				break;
	
			case MotionEvent.ACTION_UP:
				if (mMoveX >= 5) {// 如果移动距离大于等于5个像素,认为触发了移动事件,此时不允许响应单击事件
					isClick = false;
				} else {
					isClick = true;
				}
	
				mMoveX = 0;// 移动距离归零
	
				if (!isClick) {
					// 手指抬起后,根据当前滑块位置,确定开关状态
					if (mSlideLeft > MAX_LEFT / 2) {// 打开状态
						mSlideLeft = MAX_LEFT;
						isOpen = true;
					} else {// 关闭状态
						mSlideLeft = 0;
						isOpen = false;
					}
	
					invalidate();// 刷新
	
					// 开关切换事件的回调方法
					if (mListener != null) {
						mListener.onCheckedChanged(MySwitch.this, isOpen);
					}
				}
	
				break;
	
			default:
				break;
			}
	
			return super.onTouchEvent(event);// 此处改成父类方法, 可以同时响应onClick和onTouchEvent
		}

		----------------------------------

		setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View v) {
				if (isClick) {
					if (isOpen) {
						isOpen = false;
						mSlideLeft = 0;
					} else {
						isOpen = true;
						mSlideLeft = MAX_LEFT;
					}

					if (mListener != null) {
						mListener.onCheckedChanged(MySwitch.this, isOpen);
					}

					invalidate();// 刷新view, 会重新调用onDraw方法
				}
			}
		});

# Day02 #

## 自定义开关 ##

- 自定义属性

		attrs.xml

		<?xml version="1.0" encoding="utf-8"?>
		<resources>
	
		    <declare-styleable name="MySwitch">
		        <attr name="isChecked" format="boolean" />
		        <attr name="slideDrawable" format="reference" />
		    </declare-styleable>
	
		</resources>

		-----------------------------------------------------------

		activity_main.xml

		<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
		    xmlns:tools="http://schemas.android.com/tools"
		    xmlns:itheima="http://schemas.android.com/apk/res/com.itheima.myswitch"
		    android:layout_width="match_parent"
		    android:layout_height="match_parent" >
		
		    <com.itheima.myswitch.MySwitch
		        android:id="@+id/my_switch"
		        android:layout_width="wrap_content"
		        android:layout_height="wrap_content"
		        android:layout_centerInParent="true"
		        itheima:isChecked="false"
		        itheima:slideDrawable="@drawable/slide_button" />
		
		</RelativeLayout>

		------------------------------------------

		// 布局文件初始化, 带属性
		public MySwitch(Context context, AttributeSet attrs) {
			super(context, attrs);
			init();
	
			// 自定义属性
			isOpen = attrs.getAttributeBooleanValue(
					"http://schemas.android.com/apk/res/com.itheima.myswitch",
					"isChecked", false);// 获取当前选中状态
	
			int slideId = attrs.getAttributeResourceValue(
					"http://schemas.android.com/apk/res/com.itheima.myswitch",
					"slideDrawable", 0);//获取滑块图片
			
			if (slideId > 0) {
				mBitmapSlide = BitmapFactory
						.decodeResource(getResources(), slideId);//加载滑块图片
			}
	
			// 根据当前选中状态,更新界面展示
			if (isOpen) {
				mSlideLeft = MAX_LEFT;
			} else {
				mSlideLeft = 0;
			}
	
			invalidate();
		}

## 自定义ViewPager ##

- 创建一个类, 继承ViewGroup

		public class MyViewPager extends ViewGroup {
	
			public MyViewPager(Context context, AttributeSet attrs, int defStyle) {
				super(context, attrs, defStyle);
				init();
			}
		
			public MyViewPager(Context context, AttributeSet attrs) {
				super(context, attrs);
				init();
			}
		
			public MyViewPager(Context context) {
				super(context);
				init();
			}
		}

- 在MainActivity中给自定义ViewPager添加子元素

		mViewPager = (MyViewPager) findViewById(R.id.my_scroll);

		//给自定义的ViewPager动态添加图片
		for (int i = 0; i < mImageIds.length; i++) {
			ImageView view = new ImageView(this);//创建ImageView对象
			view.setBackgroundResource(mImageIds[i]);//设置图片背景(背景可以保证填充ImageView)
			mViewPager.addView(view);//添加一个ImageView
		}

- 添加完图片之后, 保证图片可以一字排开

		/**
		 * 获得当前view的位置， 如果当前view是ViewGroup的话，应在此方法中，指定子View的位置
		 */
		@Override
		protected void onLayout(boolean changed, int l, int t, int r, int b) {
			// 遍历所有子View, 指定每个子View的位置,保证一字排开
			for (int i = 0; i < getChildCount(); i++) {
				getChildAt(i).layout(0 + i * getWidth(), 0,
						getWidth() + i * getWidth(), getHeight());
			}
		}

- 滑动自定义View, 实现页面切换

		private void init() {
		//初始化手势识别器
		mDetector = new GestureDetector(getContext(),
				new GestureDetector.SimpleOnGestureListener() {
					@Override
					public boolean onScroll(MotionEvent e1, MotionEvent e2,
							float distanceX, float distanceY) {
						scrollBy((int) distanceX, 0);//水平偏移距离
						return super.onScroll(e1, e2, distanceX, distanceY);
					}
				});
		}

		@Override
		public boolean onTouchEvent(MotionEvent event) {
			mDetector.onTouchEvent(event);
			switch (event.getAction()) {
			case MotionEvent.ACTION_UP:
				//计算当前应该滑动的具体位置
				int index = (getScrollX() + getWidth() / 2) / getWidth();
	
				//避免位置越界
				if (index > getChildCount() - 1) {
					index = getChildCount() - 1;
				}
	
				//滑动到目标位置
				scrollTo(index * getWidth(), 0);
				break;
	
			default:
				break;
			}
	
			return true;
		}

- 滑动时,页面切换的动画效果

		//初始化滑动器
		mScroller = new Scroller(getContext());
		-------------------------------
		//计算当前应该滑动的具体位置
		int index = (getScrollX() + getWidth() / 2) / getWidth();

		//避免位置越界
		if (index > getChildCount() - 1) {
			index = getChildCount() - 1;
		}

		//计算应该滑动的距离
		int distance = index * getWidth() - getScrollX();
		mScroller.startScroll(getScrollX(), 0, distance, 0, Math.abs(distance));// 参1:起始x;参2:起始y;参3:x偏移;参4:y偏移;参5:滑动时间(此处以距离的绝对值作为时间,保证了距离越长,时间越长)
		invalidate();//刷新界面

		-------------------------------
		调用startScroll方法之后, 会回调computeScroll方法,计算当前的移动情况
		@Override
		public void computeScroll() {
			if (mScroller.computeScrollOffset()) {//判断是否移动结束
				int currX = mScroller.getCurrX();//获取当前应该滑动的水平位置
				scrollTo(currX, 0);//滑动

				invalidate();//刷新界面
			}
		}

- 给自定义ViewPager添加一个测试页面,处理事件监听

		item_view.xml

		<?xml version="1.0" encoding="utf-8"?>
		<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
		    android:layout_width="match_parent"
		    android:layout_height="match_parent" >
		
		    <LinearLayout
		        android:layout_width="match_parent"
		        android:layout_height="wrap_content"
		        android:orientation="vertical" >
		
		        <TextView
		            android:id="@+id/textView1"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="TextView" />
		
		        <Button
		            android:id="@+id/button1"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="Button" />
		
		        <Button
		            android:id="@+id/button2"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="Button" />
		
		        <Button
		            android:id="@+id/button3"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="Button" />
		
		        <TextView
		            android:id="@+id/textView2"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="TextView" />
		
		        <CheckedTextView
		            android:id="@+id/checkedTextView1"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="CheckedTextView" />
		
		        <ProgressBar
		            android:id="@+id/progressBar1"
		            style="?android:attr/progressBarStyleLarge"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content" />
		
		        <Button
		            android:id="@+id/button4"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="Button" />
		
		        <TextView
		            android:id="@+id/textView3"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="TextView" />
		
		        <TextView
		            android:id="@+id/textView4"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="TextView" />
		
		        <TextView
		            android:id="@+id/textView5"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="TextView" />
		
		        <TextView
		            android:id="@+id/textView6"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="TextView" />
		
		        <TextView
		            android:id="@+id/textView7"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="Large Text"
		            android:textAppearance="?android:attr/textAppearanceLarge" />
		
		        <TextView
		            android:id="@+id/textView8"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="Large Text"
		            android:textAppearance="?android:attr/textAppearanceLarge" />
		
		        <TextView
		            android:id="@+id/textView9"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="Large Text"
		            android:textAppearance="?android:attr/textAppearanceLarge" />
		
		        <TextView
		            android:id="@+id/textView9"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="Large Text"
		            android:textAppearance="?android:attr/textAppearanceLarge" />
		
		        <TextView
		            android:id="@+id/textView9"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="Large Text"
		            android:textAppearance="?android:attr/textAppearanceLarge" />
		
		        <TextView
		            android:id="@+id/textView9"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="Large Text"
		            android:textAppearance="?android:attr/textAppearanceLarge" />
		
		        <TextView
		            android:id="@+id/textView9"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="Large Text"
		            android:textAppearance="?android:attr/textAppearanceLarge" />
		
		        <TextView
		            android:id="@+id/textView9"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:text="Large Text"
		            android:textAppearance="?android:attr/textAppearanceLarge" />
		    </LinearLayout>
		
		</ScrollView>

		这个布局文件用ScrollView包裹, 可以上下滑动

		----------------------------
		//初始化测试页面
		View item = View.inflate(this, R.layout.item_view, null);
		//将测试页面添加到第三个位置
		mViewPager.addView(item, 2);

		----------------------------
		问题: 运行测试, 发现无法展现测试页面布局, 界面是一块白板.这是因为自定义ViewPager在测量孩子的大小时, 只测量了测试页面根布局(ScrollView)的大小,而没有理会ScrollView下孩子的大小,所以系统由于不知道ScrollView的孩子大小,所以就无法绘制.

		解决方法: 
		/**
		 * 对本view进行测量大小，
		 * 如果当前view是viewGroup,那么需要对每一个子view进行测量大小
		 */
		@Override
		protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
			super.onMeasure(widthMeasureSpec, heightMeasureSpec);
	
			for (int i = 0; i < getChildCount(); i++) {
				getChildAt(i).measure(widthMeasureSpec, heightMeasureSpec);
			}

			// int size = MeasureSpec.getSize(widthMeasureSpec);//获取尺寸大小
			// int mode = MeasureSpec.getMode(widthMeasureSpec);//获取尺寸模式
		}

		----------------------------------

		问题: 运行测试, 发现当页面切换到测试页面时,只支持上下滑动,无法左右滑动了. 这是因为自定义ViewPager的孩子,也就是我们的测试页面,拦截了事件, 导致自定义ViewPager无法响应事件了.

		解决方案: 重写onInterceptTouchEvent方法,用于拦截事件
		
		/**
		 * 事件拦截
		 */
		@Override
		public boolean onInterceptTouchEvent(MotionEvent ev) {
			return true;//返回true,表示事件被拦截,不会继续向下传递
		}

		-------------------------------

		//拦截之后,发现自定义ViewPager可以左右滑动了,但是测试页面无法上下滑动, 因为上下滑动的事件已经被他的父亲(自定义ViewPager)拦截了. 所以应该有条件的拦截事件,而不是全部拦截

		/**
		 * 事件拦截
		 */
		@Override
		public boolean onInterceptTouchEvent(MotionEvent ev) {
			switch (ev.getAction()) {
			case MotionEvent.ACTION_DOWN:
				//解决 onTouchEvent 执行时，没有down事件，导致计算出错的BUG
				mDetector.onTouchEvent(ev);
	
				startX = (int) ev.getX();
				startY = (int) ev.getY();
				break;
			case MotionEvent.ACTION_MOVE:
				int endX = (int) ev.getX();
				int endY = (int) ev.getY();
	
				int dx = Math.abs(endX - startX);
				int dy = Math.abs(endY - startY);
	
				if (dx > dy) {
					return true;
				}
	
				break;
	
			default:
				break;
			}
	
			return false;
		}

		-----------------------

		/**
		 * 事件分发, 此方法先于onInterceptTouchEvent调用(了解)
		 */
		@Override
		public boolean dispatchTouchEvent(MotionEvent ev) {
			return super.dispatchTouchEvent(ev);
		}

- RaidoGroup/RadioButton

		<RadioGroup
	        android:id="@+id/rg_group"
	        android:layout_width="match_parent"
	        android:layout_height="wrap_content"
	        android:orientation="horizontal" >
	    </RadioGroup>

		----------------------

		//根据图片数量,动态增加RadioButton(注意增加测试页面)
		for (int i = 0; i < mImageIds.length + 1; i++) {
			RadioButton rb = new RadioButton(this);
			rb.setId(i);//以当前item的位置作为id
			rgGroup.addView(rb);
		}

		rgGroup.check(0);// 默认选中第一项

		------------------------

		//滑动自定义ViewPager的事件监听

		private OnPageChangeListener mListener;

		/**
		 * 开关切换事件的回调接口
		 */
		public interface OnPageChangeListener {
			public void onPageSelected(int position);
		}
	
		/**
		 * 设置开关切换的事件监听
		 */
		public void setOnPageChangeListener(OnPageChangeListener listener) {
			mListener = listener;
		}

		/**
		 * 设置当前选中页
		 * 
		 * @param positon
		 */
		public void setCurrentPage(int positon) {
			// 计算应该滑动的距离
			int distance = positon * getWidth() - getScrollX();
			mScroller.startScroll(getScrollX(), 0, distance, 0, Math.abs(distance));// 参1:起始x;参2:起始y;参3:x偏移;参4:y偏移;参5:滑动时间
			// scrollTo(index * getWidth(), 0);
			invalidate();// 刷新界面
	
			//页面切换后的回调方法
			if (mListener != null) {
				mListener.onPageSelected(positon);
			}
		}

		----------------------

		//滑动自定义ViewPager,切换RadioButton的选中状态
		mViewPager.setOnPageChangeListener(new OnPageChangeListener() {

			@Override
			public void onPageSelected(int position) {
				rgGroup.check(position);
			}
		});

		---------------------

		//点击RadioButton, 切换当前页面
		rgGroup.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				mViewPager.setCurrentPage(checkedId);
			}
		});

## 水波纹效果 ##

- 简单的自定义View

	绘制线条和圆, 熟悉绘制方法

		/**
		 * 简单的自定义view
		 * 
		 * @author Kevin
		 * 
		 */
		public class MyRingSimple extends View {
		
			private Paint mPaint;
			private Paint mCirclePaint;
		
			public MyRingSimple(Context context, AttributeSet attrs, int defStyle) {
				super(context, attrs, defStyle);
				initView();
			}
		
			public MyRingSimple(Context context, AttributeSet attrs) {
				super(context, attrs);
				initView();
			}
		
			public MyRingSimple(Context context) {
				super(context);
				initView();
			}
		
			@Override
			protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
				// super.onMeasure(widthMeasureSpec, heightMeasureSpec);
				setMeasuredDimension(200, 200);// 重新定义尺寸
			}
		
			/**
			 * 初始化布局
			 */
			private void initView() {
				mPaint = new Paint();
				mPaint.setColor(Color.GREEN);// 设置颜色
				mPaint.setStrokeWidth(3);// 设置宽度
		
				mCirclePaint = new Paint();
				mCirclePaint.setColor(Color.RED);
				mCirclePaint.setStrokeWidth(2);//线条宽度
				mCirclePaint.setStyle(Style.STROKE);//空心圆
				mCirclePaint.setAntiAlias(true);//设置没有锯齿
			}
		
			@Override
			protected void onDraw(Canvas canvas) {
				for (int i = 10; i < getWidth(); i += 20) {
					// 画线
					// 参1:起点x, 参 2:起点y,参3:终点x,参4:终点y, 参5:画笔
					canvas.drawLine(0, i, getWidth(), i, mPaint);// 水平线
					canvas.drawLine(i, 0, i, getHeight(), mPaint);// 竖直线
				}
		
				canvas.translate(-20, -20);// 移动画布
		
				// 画圆
				canvas.drawCircle(getWidth() / 2, getHeight() / 2, 50, mCirclePaint);// 参1:圆心x坐标,参2:圆心y坐标,参3:圆半径,参4:画笔
			}
		}

- 点击屏幕,绘制圆环

		/**
		 * 绘制圆环
		 * 
		 * @author Kevin
		 * 
		 */
		public class MyRing extends View {
		
			private int cx;// 圆心x坐标
			private int cy;// 圆心y坐标
			private int radius;// 圆环半径
		
			private Paint mPaint;
		
			private Handler mHandler = new Handler() {
				public void handleMessage(android.os.Message msg) {
					// 渐变
					// 半径变大
					// 圆环宽度变大
					int alpha = mPaint.getAlpha();// 获取当前渐变值
		
					// 渐变值递减
					alpha -= 10;
					if (alpha < 0) {// 如果渐变值小于0,就置为0
						alpha = 0;
					}
		
					mPaint.setAlpha(alpha);// 设置渐变
					radius += 5;// 半径递增
					mPaint.setStrokeWidth(radius / 3);// 设置圆环宽度
					invalidate();// 重新绘制圆环
		
					if (alpha > 0) {// 渐变值大于0,表示圆环还未完全消失
						mHandler.sendEmptyMessageDelayed(0, 50);// 继续发送延时消息,形成递归循环
					}
				};
			};
		
			public MyRing(Context context, AttributeSet attrs, int defStyle) {
				super(context, attrs, defStyle);
				initView();
			}
		
			public MyRing(Context context, AttributeSet attrs) {
				super(context, attrs);
				initView();
			}
		
			public MyRing(Context context) {
				super(context);
				initView();
			}
		
			private void initView() {
				// 初始化画笔
				radius = 0;
				mPaint = new Paint();
				mPaint.setColor(Color.GREEN);
				mPaint.setStyle(Style.STROKE);
				mPaint.setStrokeWidth(radius / 3);
				mPaint.setAntiAlias(true);
				mPaint.setAlpha(255);
			}
		
			@Override
			protected void onDraw(Canvas canvas) {
				canvas.drawCircle(cx, cy, radius, mPaint);// 绘制圆环
			}
		
			/**
			 * 开启圆环动画
			 */
			private void startAnim() {
				mHandler.sendEmptyMessageDelayed(0, 50);
			}
		
			@Override
			public boolean onTouchEvent(MotionEvent event) {
				if (event.getAction() == MotionEvent.ACTION_DOWN) {
					// 按下后,获取当前的x,y坐标,作为圆心坐标
					cx = (int) event.getX();
					cy = (int) event.getY();
					// invalidate();
					initView();// 初始化画笔
					startAnim();// 开始绘制圆环
				}
		
				return super.onTouchEvent(event);
			}
		
		}

- 移动屏幕,绘制多个圆环

		/**
		 * 滑动绘制圆环集合
		 * 
		 * @author Kevin
		 * 
		 */
		public class MyRingWave extends View {
		
			private static final int MIN_DIS = 10;// 两个圆环的最短距离
		
			// 圆环集合
			ArrayList<Wave> mWaveList = new ArrayList<MyRingWave.Wave>();
		
			// 颜色集合
			int[] mColors = new int[] { Color.RED, Color.GREEN, Color.BLUE,
					Color.YELLOW };
		
			private Handler mHandler = new Handler() {
				public void handleMessage(android.os.Message msg) {
					flushData();
					invalidate();
		
					if (!mWaveList.isEmpty()) {
						mHandler.sendEmptyMessageDelayed(0, 50);
					}
				};
			};
		
			public MyRingWave(Context context, AttributeSet attrs, int defStyle) {
				super(context, attrs, defStyle);
			}
		
			public MyRingWave(Context context, AttributeSet attrs) {
				super(context, attrs);
			}
		
			public MyRingWave(Context context) {
				super(context);
			}
		
			@Override
			protected void onDraw(Canvas canvas) {
				// 绘制所有圆环
				for (Wave wave : mWaveList) {
					canvas.drawCircle(wave.cx, wave.cy, wave.radius, wave.paint);
				}
			}
		
			/**
			 * 刷新数据
			 */
			private void flushData() {
				ArrayList<Wave> removeList = new ArrayList<MyRingWave.Wave>();// 待移除的圆环对象集合
				for (Wave wave : mWaveList) {
					wave.radius += 3;// 增加半径
					wave.paint.setStrokeWidth(wave.radius / 3);// 重新这是圆环宽度
					int alpha = wave.paint.getAlpha();
		
					if (alpha == 0) {// 如果圆环透明度已经为0,不会再进行绘制,需要从列表中移除
						removeList.add(wave);// 要删除的元素
						continue;
					}
		
					alpha -= 5;// 透明度递减
					if (alpha < 0) {
						alpha = 0;
					}
		
					wave.paint.setAlpha(alpha);
				}
		
				mWaveList.removeAll(removeList);// 移除已经消失的圆环对象
			}
		
			@Override
			public boolean onTouchEvent(MotionEvent event) {
				switch (event.getAction()) {
				case MotionEvent.ACTION_DOWN:
				case MotionEvent.ACTION_MOVE:
					int cx = (int) event.getX();
					int cy = (int) event.getY();
		
					addPoint(cx, cy);
					break;
		
				default:
					break;
				}
		
				return true;
			}
		
			private void addPoint(int cx, int cy) {
				if (mWaveList.isEmpty()) {// 第一次添加圆环
					addWave(cx, cy);
					mHandler.sendEmptyMessage(0);// 发送消息,启动绘制
				} else {
					Wave wave = mWaveList.get(mWaveList.size() - 1);// 获取最后一个圆环
					if (Math.abs(wave.cx - cx) > MIN_DIS
							|| Math.abs(wave.cy - cy) > MIN_DIS) {// 只有在两个圆环距离超过一定范围时才进行绘制,保证圆环彼此保持一定间距
						addWave(cx, cy);
					}
				}
			}
		
			/**
			 * 添加圆环对象
			 * 
			 * @param cx
			 * @param cy
			 */
			private void addWave(int cx, int cy) {
				Wave wave = new Wave();
				wave.cx = cx;
				wave.cy = cy;
		
				// 初始化画笔
				Paint paint = new Paint();
				paint.setColor(mColors[(int) (Math.random() * 4)]);// 画笔颜色随机
				paint.setStyle(Style.STROKE);// 绘制空心圆
				paint.setAntiAlias(true);// 没有锯齿
		
				wave.paint = paint;
		
				mWaveList.add(wave);
			}
		
			/**
			 * 圆环对象封装
			 */
			class Wave {
				int cx;// 圆心x坐标
				int cy;// 圆心y坐标
				int radius;// 圆环半径
				Paint paint;// 画笔
			}
		}

## 开源项目分享 ##

一大波自定义控件
https://github.com/Trinea/android-open-project

谷歌官方UI库
https://github.com/lightSky/MaterialDesignCenter

开源项目Top100
https://github.com/Freelander/Android_Data/blob/master/Android-Librarys-Top-100.md


	
	

	
